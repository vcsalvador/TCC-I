%
% Documento: Fundamentação Teórica
%

\chapter{Fundamentação Teórica}
\label{chap:fund-teor}
\section{HTML}
\label{sec:html}
HTML é a linguagem principal para criação de documentos e aplicações na \textit{Web} para o uso de todos, em qualquer lugar \cite{W3Chtml2015}.

O documento HTML consiste em uma árvore de elementos e texto. Cada elemento é representado por uma \textit{tag} de abertura e uma de fechamento. As \textit{tags} têm de estar todas aninhadas completamente, sem haver sobreposição. Os elementos podem ter atributos que controlam o seu comportamento \cite{HTMLspec2014}. Na \autoref{fig:simpleHTML} está representada a estrutura básica de um documento HTML.

\begin{figure}[!htb]
	\centering
	\caption{Exemplo de arquivo HTML válido.}
	\includegraphics[width=1\textwidth]{./04-figuras/html_simples}
	\fonte{próprio autor}
	\label{fig:simpleHTML}
\end{figure}

\begin{figure}[!htb]
	\centering
	\caption{Estrutura de uma \textit{tag}.}
	\includegraphics[width=1\textwidth]{./04-figuras/tag_element_attr_marked}
	\fonte{próprio autor}
	\label{fig:tagStruct}
\end{figure}

Uma \textit{tag} HTML, pode possuir atributos que podem definir uma meta informação, com o objetivo de organizar o arquivo HTML, ou definir seu estilo. Esses atributos devem sempre ser definidos na \textit{tag} de abertura, e são representados por um par chave/valor. Podemos ver na \autoref{fig:tagStruct} uma estrutura simples de um \textit{tag} com os atributos \textit{id}, \textit{class} e \textit{style} definidos.

Pode-se notar na \autoref{fig:simpleHTML} a utilização dos atributos \textit{id}, \textit{title} e \textit{style}, que representam a identificação única do elemento, uma meta informação identificando a sua utilidade e o estilo aplicado a ele, respectivamente.

Dentro do documento HTML pode-se utilizar as \textit{tags} <style/> e <script/>, que definem escopos de estilo e linguagens de \textit{script}, como pode-se observar na \autoref{fig:styleScript}.

\begin{figure}[!htb]
	\centering
	\caption{Exemplo de arquivo HTML válido.}
	\includegraphics[width=1\textwidth]{./04-figuras/style_script}
	\fonte{próprio autor}
	\label{fig:styleScript}
\end{figure}

É uma boa prática de desenvolvimento \textit{web} manter as estruturas em arquivos diferentes, evitando ao máximo a utilização das \textit{tags} de escopo. Essa separação mantém uma organização do código, possibilita o reuso em outras páginas, ou até mesmo em outros sistemas, e também melhoram o desempenho, pois podem ser mantidos em cache, diminuindo a carga de dados necessária para renderização de um página \textit{web}. Porém, esta prática é difícil de gerenciar, dificultando a identificação de erros e o reuso de seus componentes.

Os navegadores \textit{web} (\textit{Browsers}) traduzem esse formato em uma árvore DOM (\textit{Document Object Model}). Uma árvore DOM é uma representação em memória de um documento, que possui vários nós, sendo que cada nó contém um elemento ou trecho de texto do documento.

\begin{figure}[!htb]
	\centering
	\caption{Exemplo de estrutura da árvore do DOM}
	\includegraphics[width=0.3\textwidth]{./04-figuras/DOMsnippet}
	\fonte{\citeonline{HTMLspec2014}}
	\label{fig:domtree}
\end{figure}

Na \autoref{fig:domtree}, vê-se que o elemento raiz da árvore é o html, que é sempre o primeiro elemento de um documento e que contém todos os outros. Cada elemento do HTML é representado por um nó, onde todos os nós que se encontram nos níveis abaixo deste são denominados descendentes (\textit{descendant}). Dentro da árvore DOM, os nós que se encontram exatamente um nível abaixo são os filhos (\textit{child}) e os nós que se encontram no mesmo nível são chamados de irmãos (\textit{sinbling}). Os nós denominados de \textit{text} são os que encapsulam os textos inseridos dentro dos elementos HTML, então estes serão os nós que existem em maior número no DOM.

A árvore DOM é utilizada para localização dos nós do HTML, as linguagens  CSS e javascript, utilizam da estrutura do DOM para encontrar os elementos e identificar quais são os elementos afetados por suas diretivas. O navegador determina a partir dos nós selecionados pelos seletores CSS, quais serão os elementos afetados pela regra.

\section{CSS}
\label{sec:CSS}
CSS é um mecanismo simples para adicionar estilo (\textit{e.g.}, fontes, cores, espaçamento) em documentos \textit{Web} \cite{W3Ccss2015}.

Uma folha de estilo \(C\) pode ser vista como um conjunto de regras \(R\), composto por regras simples \(R_i\), cada uma composta por um seletor \(S_i\) e um conjunto de pares: propriedade \(P_i\) e seus valores \(V_i\). Os seletores definem a quais elementos de um documento, serão aplicadas as propriedades definidas pela regra à qual elas pertencem \cite{Geneves2012}.

A \autoref{fig:cssExample} ilustra uma folha de estilo, com as regras representadas pelo conjunto de seletores, que precedem as chaves, e os pares "propriedade/valor" que as compões, dentro das chaves.

\begin{figure}[!htb]
	\centering
	\caption{Exemplo de uma folha de estilo \(C\).}
	\includegraphics[width=0.3\textwidth]{./04-figuras/css_example_marked}
	\fonte{próprio autor}
	\label{fig:cssExample}
\end{figure}

\subsection{Seletores}
\label{subsec:seletores}
Um seletor é uma cadeia de uma, ou mais, sequências de seletores simples, separados por combinadores. Os seletores simples são cadeias de caracteres que representam um elemento do html: o seletor universal, representado pelo simbolo \(\ast\), indica que a regra será aplicada a todos os elementos que estejam no DOM. O seletor de elementos HTML é representado pelo nome da \textit{tag} de um elemento, por exemplo \(h1\). O seletor de classe, que seleciona todos os elementos que possuam o atributo \(class\) especificado pelo seletor, é utilizado escrevendo-se o nome da classe,  precedido de um ponto final (\(.\)). O seletor de \(id\), que seleciona o elemento do html que possua aquele \(id\), é utilizado escrevendo-se o identificador precedido pelo simbolo \(\#\). 
Simplificando, sem perder generalidade, pode-se considerar que regras são feitas de seletores únicos que definem uma única propriedade por vez. Os seletores \(S_i\), chamados de padrões na especificação do CSS \cite{CSSspec2009}, definem uma função booleana na forma:
\begin{equation}
	expression * element \rightarrow boolean
\end{equation}
que define se um elemento é, ou não, selecionado pela expressão do seletor.

Os combinadores são propriedades que definem relações entre os elementos de um documento. Existem três formas de combinadores: descendentes, filhos e irmãos. O combinador de descendente descreve qualquer elemento que esteja um nível abaixo na árvore DOM, e são representados pelo espaço em branco, \textit{e.g.} "$body\ p$". O combinador de filho descreve os elementos que estão exatamente um nível abaixo do nó, este combinador é representado pelo sinal de maior ($>$), \textit{e.g.} "$body > p$". O combinador de irmãos descreve os elementos que estão no mesmo nível da árvore, existem duas variações, uma para o próximo irmão adjacente ($+$) e um para todos os irmãos (\char`~).

Uma pseudo classe, é um elemento de seleção que especifica estado ou localização do elemento. Por exemplo, a pseudo classe ":nth-first-child(n)" identifica o n-ésimo elemento filho contando a partir do primeiro, podendo assim ser classificado como uma pseudo classe de localização. A pseudo classe ":hover" identifica um elemento que esteja sob o cursor do apontador (\textit{mouse}), sendo assim uma pseudo classe de estado. Ainda existem os seletores de atributos, que selecionam elementos que possuam determinados atributos, permitindo a utilização de expressões para seleções parciais, \textit{i.e.}, atributos que comecem, possuam ou terminem com uma cadeia de caracteres específicos.

Regras simples como as demonstradas na \autoref{fig:cssExample} são fáceis de se criar, mas quando utilizados combinadores e pseudo classes, a complexidade da autoria escala. Além da complexidade dos seletores, pode-se apontar o efeito cascata, gerado pelo mecanismo de precedência e aplicação das propriedades aos elementos HTML.

\subsection{Efeito Cascata}
\label{subsec:cascade}

O efeito cascata do CSS se dá devido à ordem de precedência dos valores de propriedades definidas para cada elemento. O mecanismo de renderização do navegador recebe uma lista desordenada dessas propriedades, e as organiza pela precedência das declarações delas. Essa ordem é definida de acordo com os critérios listados a seguir, em ordem decrescente de prioridade \cite{CSScascade2015}.

\begin{itemize}
	\item \textbf{Origem e Importância:} 
	Cada regra de estilo possui uma origem, que define onde ela estará na cascata, e a importância se refere à utilização, ou não, de um atributo que a explicita.
	\item \textbf{Escopo:}
	Uma declaração pode ter uma subárvore do DOM como escopo, afetando somente os elementos pertencentes a esta subárvore. Para declarações normais, o escopo mais interno tem prioridade, para as regras definidas como importantes as do escopo mais externo sobrescreverão.
	\item \textbf{Especificidade:}
	O calculo de especificidade conta a ocorrência de seletores de ID, classe e tipo (\textit{tags} e \textit{pseudo-elements}), e faz-se uma soma ponderada dessas ocorrências. A declaração com maior especificidade tem prioridade.
	\item \textbf{Ordem de aparição:}
	A última declaração no documento tem a maior prioridade. Isto significa que a localidade será levada em conta, para isso, considera-se que as folhas de estilo são concatenadas ao documento na ordem em que são declaradas.
\end{itemize}

Uma propriedade pode ter sua importância declarada explicitamente através do valor \textbf{!important}, que sobrescreverá todas as propriedades que possuírem maior prioridade. Se duas propriedades possuírem o valor \textbf{!important}, as outras especificações de prioridade terão efeito.

Outra propriedade do CSS que determina o funcionamento em cascata da aplicação de estilo é a herança. Cada propriedade de estilo possui um valor padrão de herança, que indica se aquela propriedade é propagada para seus filhos, essa herança pode ser definida explicitamente, a partir do valor da propriedade \textbf{inherit}. 

\section{Qualidade de \textit{Software}}

Com a finalidade de propor uma métrica, será necessário criar um arcabouço teórico sobre as técnicas e medições de qualidade de \textit{software} e código fonte.

A qualidade de \textit{software} faz um estudo sobre o produto do código fonte, considerando fatores produtivos e algumas vezes subjetivos. Em \citeonline{Pressman:2010}, destacam-se os fatores de qualidade de \textit{software}, definidos pela ISO 9126, apresentados a seguir:

\begin{itemize}
	\item \textbf{Funcionalidade}. Grau em que o \textit{software} satisfaz as necessidade declaradas.
	\item \textbf{Confiabilidade}. Período de tempo em que o \textit{software} está disponível para uso.
	\item \textbf{Usabilidade}. Grau em que o \textit{software} é fácil de usar.
	\item \textbf{Eficiência}. Grau em que o \textit{software} faz uso otimizado dos recursos do sistema.
	\item \textbf{Manutenibilidade}. Facilidade com a qual podem ser feitos reparos no \textit{software}.
	\item \textbf{Portabilidade}. Facilidade com a qual o \textit{software} pode ser transposto de um ambiente para outro.
\end{itemize}

Essas seis características chave apresentam a qualidade do produto de \textit{software}, que são difíceis de se medir quantitativamente e dependem da análise subjetiva de um especialista. Essa subjetividade torna as métricas difíceis de se reproduzir, portanto, é quase impossível determinar uma relação entre estados diferentes do produto.

\citeonline{Whitmire:1997} define a qualidade de \textit{software} orientado à objetos (OO) a partir de nove características distintas e mensuráveis de projetos OO:

\begin{itemize}
	\item \textbf{Tamanho}, definido em termos de quatro perspectivas: população, volume, comprimento e funcionalidade. População é medida pela contagem estática das entidades OO, tais como classes ou operações. Medidas de volume são medidas de população coletadas dinamicamente em função de um determinado instante de tempo. Comprimento é a medida de uma cadeia de elementos de projeto interconectadas, \textit{e.g}, a profundidade de uma árvore de herança. Métricas de funcionalidade fornecem uma indicação indireta do valor entregue ao cliente.
	\item \textbf{Complexidade} é determinada pela forma com a qual as classes OO de um projeto se inter-relacionam umas com as outras.
	\item \textbf{Acoplamento}, é definido pelas conexões físicas entre elementos de um projeto OO, \textit{e.g}, o número de colaborações entre as classes ou o número de mensagens passadas entre objetos.
	\item \textbf{Suficiência} é o grau das características exigidas de uma abstração ou o grau das características que um componente de projeto possui na sua abstração, do ponto de vista da aplicação corrente. Ou seja, um componente de \textit{software} é suficiente se reflete plenamente todas as propriedades do objeto de domínio de aplicação que representa.
	\item \textbf{Completeza} se diferencia de suficiência pelo conjunto de características com o qual se compara a abstração ou o componente de projeto. A completeza considera múltiplos pontos de vista da aplicação corrente. Como este critério considera diferentes pontos de vista, tem implicação direta no grau de reusabilidade da abstração.
	\item \textbf{Coesão} é determinada pelo grau em que o conjunto de propriedades que a abstração possui é parte do problema ou do domínio do projeto.
	\item \textbf{Primitividade} é o grau em que uma operação é atômica --- \textit{i.e.}, a operação não pode ser construída a partir de uma sequência de outras operações contidas na classe.
	\item \textbf{Similaridade} é o grau em que duas ou mais classes são semelhantes, em termos de sua estrutura, função ou finalidade.
	\item \textbf{Volatilidade} mede a probabilidade de que uma modificação venha a ocorrer em um componente de projeto OO.
\end{itemize}

Segundo \citeonline{Pressman:2010}, as métricas de qualidade de código-fonte também podem ser analisadas em nível de componente. Essas métricas são a de coesão, acoplamento e complexidade.

\subsection{Métricas de coesão}

\citeonline{Bieman1994} definem uma coleção de métricas que fornecem indicação da coesividade de um módulo. As métricas são definidas especificando cinco conceitos e medidas.

\begin{itemize}
	\item\textbf{Fatia de dados (\textit{data slice})} é um caminho retroativo ao longo de um módulo, que procura valores de dados que afetam a posição no módulo em que o caminho teve inicio.
	\item\textbf{Fichas de dados (\textit{data tokens})} são as variáveis especificadas para um módulo.
	\item\textbf{Fichas aglutinadas (\textit{glue tokens})} um conjunto de \textit{data tokens} que está contido em um, ou mais, \textit{data slices}.
	\item\textbf{Fichas superaglutinadas (\textit{superglue tokens})} são os \textit{data tokens} que estão contidos em todos os \textit{data slices}.
	\item A \textbf{aglutinação (\textit{stickiness})} relativa de uma ficha aglutinante é diretamente proporcional ao número de \textit{data slices} que ela aglutina.
\end{itemize}

As métricas de coesão definidas por \citeonline{Bieman1994} são de três tipos, coesão funcional forte (\textit{strong functional cohesion} --- SFC), coesão funcional fraca (\textit{weak function cohesion} --- WFC) e adesividade (\textit{adhesiveness}). 
Todas essas métricas de coesão variam de 0 a 1. Têm valor 0 quando um procedimento tem mais de uma saída e não exibe nenhum dos atributos de coesão indicados por uma métrica particular. Quando não há \textit{superglue tokens}, nenhuma ficha é comum a todos os \textit{data slices}, tem coesão funcional forte igual a zero. Quando não existem \textit{data tokens} comuns a mais de um \textit{data slice}, e o procedimento possui mais de um \textit{data slice}, exibe coesão funcional fraca zero e adesividade zero.

\subsection{Métricas de acoplamento}

O acoplamento de módulos fornece a indicação da conectividade de um módulo a outros módulos, dados globais e ambiente exterior.
A métrica para acoplamento de módulos proposta por \citeonline{Dhama:1995} que engloba acoplamento de dados e de fluxo de controle, acoplamento global e acoplamento ambiental. As medidas necessária para calcular acoplamento de módulos são definidas em termos de cada um dos três tipos de acoplamento mencionados.
Para acoplamento de dados e de fluxo de controle,
\begin{description}
	\item$d_i$ = número de parâmetros de dados de entrada
	\item$c_i$ = número de parâmetros de controle de entrada
	\item$d_o$ = número de parâmetros de dados de saída
	\item$c_o$ = número de parâmetros de controle de saída
\end{description}
Para acoplamento global,
\begin{description}
	\item$g_d$ = número de variáveis globais usadas como dados
	\item$g_c$ = número de variáveis globais usadas como controle
\end{description}
Para acoplamento ambiental,
\begin{description}
	\item$w$ = número de módulos chamados (\textit{fan-out})
	\item$r$ = número de módulos que chamam o módulo sendo considerado (\textit{fan-in})
\end{description}

Usando essas medidas, um indicador de acoplamento de módulo, $m_c$, é definido do seguinte modo:
\begin{equation}
	m_c = \frac{k}{M}
\end{equation}
em que $k$ é uma constante de proporcionalidade e
\begin{equation}
\label{eq:eqGrande}
	M = d_i + (a \times c_i) + d_o + (b \times c_o) + g_d + (c \times g_c) + w + r
\end{equation}
Os valores para $k$, $a$, $b$ e $c$ devem ser derivados empiricamente.
À medida que o valor de $m_c$, aumenta, o acoplamento global do módulo diminui. A fim de ter a métrica de acoplamento aumentando conforme o grau de acoplamento aumenta, uma métrica de acoplamento revisada pode ser definida como
\begin{equation}
	C = 1 - m_c
\end{equation}
em que o grau de acoplamento aumenta à medida que as medidas da \autoref{eq:eqGrande} aumentam.

\subsection{Métricas de complexidade}

Diversas métricas de \textit{software} podem ser calculadas para determinar a complexidade do fluxo de controle do programa. Muitas delas são baseadas no diagrama de fluxo.
As métricas de qualidade podem ser usadas para prever informação crítica sobre confiabilidade e manutenibilidade de sistemas de \textit{software} a partir da análise automática do código-fonte, ou informação do projeto procedimental. Métricas de complexidade também fornecem realimentação durante o projeto de \textit{software} para ajudar a controlar a atividade de projeto \cite{Pressman:2010}. Fornecendo informações detalhadas sobre os módulos de \textit{software}, durante o teste e manutenção, ajudando a localizar áreas de potencial instabilidade.

A métrica de complexidade mais amplamente usada (e debatida) para \textit{software} de computador é a complexidade ciclomática, desenvolvida por \citeonline{McCabe:1989}.